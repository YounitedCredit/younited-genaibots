import json
import time
import traceback

from core.genai_interactions.genai_response import GenAIResponse
from core.user_interactions.incoming_notification_data_base import (
    IncomingNotificationDataBase,
)
from core.user_interactions.message_type import MessageType
from core.user_interactions.user_interactions_behavior_base import (
    UserInteractionsBehaviorBase,
)
from core.user_interactions.user_interactions_plugin_base import (
    UserInteractionsPluginBase,
)
from utils.config_manager.config_model import BotConfig


class CaDefaultBehaviorPlugin(UserInteractionsBehaviorBase):
    def __init__(self, global_manager):
        from core.global_manager import GlobalManager

        if not isinstance(global_manager, GlobalManager):
            raise TypeError("global_manager must be an instance of GlobalManager")

        self.global_manager: GlobalManager = global_manager
        self.logger = global_manager.logger
        bot_config_dict = global_manager.config_manager.config_model.BOT_CONFIG
        self.bot_config: BotConfig = bot_config_dict
        self._plugin_name = "ca_default_behavior"
        self.reaction_done = "done"
        self.reaction_error = "error"

    def initialize(self):
        self.user_interactions_dispatcher = self.global_manager.user_interactions_dispatcher
        self.genai_interactions_text_dispatcher = self.global_manager.genai_interactions_text_dispatcher
        self.backend_internal_data_processing_dispatcher = self.global_manager.backend_internal_data_processing_dispatcher

    @property
    def plugin_name(self):
        return self._plugin_name

    @plugin_name.setter
    def plugin_name(self, value):
        self._plugin_name = value

    async def process_interaction(self, event_data, event_origin=None):
        try:
            start_time = time.time()

            if event_data is None:
                self.logger.debug("No event")
                return

            event: IncomingNotificationDataBase = await self.user_interactions_dispatcher.request_to_notification_data(event_data, plugin_name=event_origin)
            self.custom_api_plugin: UserInteractionsPluginBase = await self.user_interactions_dispatcher.get_plugin(event_origin)

            self.reaction_processing = self.custom_api_plugin.reactions.PROCESSING
            self.reaction_done = self.custom_api_plugin.reactions.DONE
            self.reaction_acknowledge = self.custom_api_plugin.reactions.ACKNOWLEDGE
            self.reaction_generating = self.custom_api_plugin.reactions.GENERATING
            self.reaction_writing = self.custom_api_plugin.reactions.WRITING
            self.reaction_error = self.custom_api_plugin.reactions.ERROR
            self.reaction_wait = self.custom_api_plugin.reactions.WAIT
            break_keyword = self.global_manager.bot_config.BREAK_KEYWORD
            start_keyword = self.global_manager.bot_config.START_KEYWORD

            await self.custom_api_plugin.add_reaction(event=event, channel_id=event.channel_id, timestamp=event.timestamp, reaction_name=self.reaction_acknowledge)

            ts = event.timestamp
            channel_id = event.channel_id
            session_name = f"{channel_id.replace(':','_')}-{ts}.txt"

            processing_container = self.backend_internal_data_processing_dispatcher.processing
            abort_container = self.backend_internal_data_processing_dispatcher.abort

            await self.backend_internal_data_processing_dispatcher.write_data_content(processing_container, session_name, data="processing")
            self.logger.info(f"Processing session data for {session_name} created successfully.")

            if event.event_label == "thread_message":
                if event.text == break_keyword:
                    thread_id = event.thread_id
                    abort_name = f"{channel_id.replace(':','_')}-{thread_id}.txt"
                    self.logger.info(f"Break keyword detected in thread message, stopping processing with flag {abort_name}.")
                    await self.user_interactions_dispatcher.send_message(event=event, message=f"Break keyword detected, stopping further autogenerated processing in this thread. use {start_keyword} to resume", message_type=MessageType.COMMENT, is_internal=True, show_ref=False)
                    await self.user_interactions_dispatcher.send_message(event=event, message=f"Break keyword detected, stopping further autogenerated processing in this thread. use {start_keyword} to resume", message_type=MessageType.COMMENT, is_internal=False, show_ref=False)
                    await self.backend_internal_data_processing_dispatcher.write_data_content(abort_container, abort_name, data="abort")
                    return
                elif event.text == start_keyword:
                    thread_id = event.thread_id
                    abort_name = f"{channel_id.replace(':','_')}-{thread_id}.txt"
                    self.logger.info(f"Start keyword detected in thread message, resuming processing with flag {abort_name}.")
                    await self.user_interactions_dispatcher.send_message(event=event, message="Start keyword detected, resuming further autogenerated processing in this thread.", message_type=MessageType.COMMENT, is_internal=True, show_ref=False)
                    await self.user_interactions_dispatcher.send_message(event=event, message="Start keyword detected, resuming further autogenerated processing in this thread.", message_type=MessageType.COMMENT, is_internal=False, show_ref=False)
                    await self.backend_internal_data_processing_dispatcher.remove_data_content(abort_container, abort_name)
                    return
                else:
                    if not self.global_manager.bot_config.REQUIRE_MENTION_THREAD_MESSAGE or (self.global_manager.bot_config.REQUIRE_MENTION_THREAD_MESSAGE and event.is_mention):
                        await self.user_interactions_dispatcher.send_message(event=event, message="", message_type=MessageType.TEXT, is_internal=True, show_ref=True)
            else:
                await self.user_interactions_dispatcher.send_message(event=event, message="", message_type=MessageType.TEXT, is_internal=True, show_ref=True)

            await self.process_incoming_notification_data(event)

        except Exception as e:
            await self.user_interactions_dispatcher.send_message(
                event=event_data,
                message=f":warning: Error processing incoming request : {str(e)}",
                message_type=MessageType.TEXT,
                is_internal=True,
                show_ref=False
            )
            raise
        finally:
            end_time = time.time()
            elapsed_time = end_time - start_time
            self.logger.info(f"process_interaction in instant messaging default behavior took {elapsed_time} seconds to execute.")

    async def process_incoming_notification_data(self, event: IncomingNotificationDataBase):
        try:
            channel_id = event.channel_id
            timestamp = event.timestamp
            await self.user_interactions_dispatcher.remove_reaction(event=event, channel_id=channel_id, timestamp=timestamp, reaction_name=self.reaction_done)

            if event.event_label == "message":
                if self.bot_config.REQUIRE_MENTION_NEW_MESSAGE and not event.is_mention:
                    self.logger.warning("Message is not a mention and the config is set to required direct mention for new message, ignoring")
                    return

            self.logger.debug('\n' + json.dumps(event.to_dict(), indent=4))
            genai_output = await self.genai_interactions_text_dispatcher.handle_request(event)

            await self.user_interactions_dispatcher.remove_reaction(event=event, channel_id=channel_id, timestamp=timestamp, reaction_name=self.reaction_generating)

            if genai_output and genai_output != "":
                await self.user_interactions_dispatcher.add_reaction(event=event, channel_id=channel_id, timestamp=timestamp, reaction_name=self.reaction_writing)
                genai_response = await GenAIResponse.from_json(genai_output)
                await self.global_manager.action_interactions_handler.handle_request(genai_response, event)
            else:
                self.logger.info("GenAI output is None, not processing the message.")

            if genai_output is None:
                if self.global_manager.bot_config.ACKNOWLEDGE_NONPROCESSED_MESSAGE:
                    await self.user_interactions_dispatcher.add_reaction(event=event, channel_id=channel_id, timestamp=timestamp, reaction_name=self.reaction_done)
            else:
                await self.user_interactions_dispatcher.add_reaction(event=event, channel_id=channel_id, timestamp=timestamp, reaction_name=self.reaction_done)

            await self.user_interactions_dispatcher.remove_reaction(event=event, channel_id=channel_id, timestamp=timestamp, reaction_name=self.reaction_writing)
            await self.user_interactions_dispatcher.remove_reaction(event=event, channel_id=channel_id, timestamp=timestamp, reaction_name=self.reaction_acknowledge)

        except Exception as e:
            self.logger.error(f"Error processing interaction: {str(e)}\n{traceback.format_exc()}")
            await self.user_interactions_dispatcher.remove_reaction(event=event, channel_id=channel_id, timestamp=timestamp, reaction_name=self.reaction_done)
            await self.user_interactions_dispatcher.add_reaction(event=event, channel_id=channel_id, timestamp=timestamp, reaction_name=self.reaction_error)

    async def update_reaction(self, event: IncomingNotificationDataBase, channel_id, timestamp, remove_reaction, add_reaction=None):
        await self.user_interactions_dispatcher.remove_reaction(channel_id=channel_id, timestamp=timestamp, reaction_name=remove_reaction)
        if add_reaction:
            await self.user_interactions_dispatcher.add_reaction(channel_id=channel_id, timestamp=timestamp, reaction_name=add_reaction)

    async def end_long_action(self, event, channel_id, timestamp: str):
        # Implementation for ending a long action
        pass

    async def begin_wait_backend(self, event, channel_id,timestamp: str):
        # Implementation for beginning to wait on the backend
        pass

    async def mark_error(self, event, channel_id,timestamp: str):
        # Implementation for marking an error
        pass

    async def end_wait_backend(self, event, channel_id,timestamp: str):
        # Implementation for ending the wait on the backend
        pass

    async def end_genai_completion(self, event, channel_id,timestamp: str):
        # Implementation for ending a GenAI completion
        pass

    async def begin_genai_completion(self, event, channel_id,timestamp: str):
        # Implementation for beginning a GenAI completion
        pass

    async def begin_long_action(self, event, channel_id,timestamp: str):
        # Implementation for beginning a long action
        pass
